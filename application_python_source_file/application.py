# -*- coding: utf-8 -*-
"""application.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13JmyWMP5NokZW1W6aOatWhUYK7uguo4s

# GPU Assignment
"""

gpu_info = !nvidia-smi
gpu_info = '\n'.join(gpu_info)
if gpu_info.find('failed') >= 0:
  print('Not connected to a GPU')
else:
  print(gpu_info)

"""# Available Memory"""

from psutil import virtual_memory
ram_gb = virtual_memory().total / 1e9
print('Your runtime has {:.1f} gigabytes of available RAM\n'.format(ram_gb))

if ram_gb < 20:
  print('Not using a high-RAM runtime')
else:
  print('You are using a high-RAM runtime!')

"""# Installing NGROK"""

!pip install pyngrok

"""# Installing Detectron2"""

!pip install 'git+https://github.com/facebookresearch/detectron2.git'

"""# Installing Boostrap"""

!pip install flask-bootstrap

"""# Installing wtf and wtforms"""

!pip install flask_wtf wtforms

"""# Connecting Drive"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# Flask
from flask import Flask, escape, request, render_template, send_file, flash, send_from_directory
from flask import redirect, url_for
from pyngrok import ngrok #for ngrok configuration
from flask_bootstrap import Bootstrap
from flask_wtf import FlaskForm
from wtforms import FileField, SubmitField
from wtforms.validators import InputRequired
from werkzeug.utils import secure_filename

# Detectron2
import torch
import torchvision
import cv2
import os
import io #may need
import base64 #may need
import detectron2
from skimage.io import imread
from google.colab.patches import cv2_imshow
from detectron2.engine import DefaultPredictor
from detectron2.config import get_cfg
from detectron2 import model_zoo
from detectron2.utils.visualizer import Visualizer, ColorMode
from detectron2.data import MetadataCatalog, DatasetCatalog
from detectron2.data.datasets import register_coco_instances

# Matplotlib
from matplotlib.pyplot import imshow
import matplotlib.pyplot as plt
# %matplotlib inline

# PIL (pillow)
from PIL import Image


#ngrok
ngrok.set_auth_token("2TNzRQamtn7kiR1BDanjNdsnxwP_7xDJgokuMwSPdNqRqzCLd")
port = 8000
public_url = ngrok.connect(port).public_url


app = Flask(__name__, template_folder="/content/drive/MyDrive/instance_segmentation/templates",
            static_folder="/content/drive/MyDrive/instance_segmentation/static")

# bootstrap for style
Bootstrap(app)

# app configurations
app.config['SECRET_KEY'] = 'secret key' #secret key needed for the form
PROJECT_DIR = "/content/drive/MyDrive/instance_segmentation"
app.config['UPLOAD_FOLDER'] = os.path.join(PROJECT_DIR, 'static/files') #folder needed to store uploaded files from user
app.config['PREDICTION_FOLDER'] = os.path.join(PROJECT_DIR, 'static/files/prediction') #folder needed to store prediction to send to user
app.config['UPLOAD_EXTENSIONS'] = ['.jpg', '.jpeg']
app.config['ALLOWED_EXTENSIONS'] = set(['jpg', 'jpeg'])



# map to home url
@app.route("/")
def index():

  return render_template("index.html")

# map to generalProjects url
@app.route('/generalProjects')
def generalProjects():

  return render_template('generalProjects.html')


@app.route('/download')
def project_images():
  path = "/content/drive/MyDrive/instance_segmentation/static/project_images.zip"
  return send_file(path, as_attachment=True)


# creating form configuration
class UploadFileForm(FlaskForm):
    file = FileField("File", validators=[InputRequired()])
    submit = SubmitField("Upload File")

# function for valid file extension
def allowed_file(filename):
  return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']


# instance segmentation page
@app.route('/instanceSegmentation')
def instanceSegmentation():
    form = UploadFileForm()
    if form.validate_on_submit():
        file = form.file.data #grabs file
        if file and allowed_file(file.filename): #if file ext meets condition then ->
            filename = secure_filename(file.filename)#get filename
            file.save(os.path.join(os.path.abspath(os.path.dirname(__file__)),
                app.config['UPLOAD_FOLDER'], filename)) #saves file
            return flash(f"File {filename} uploaded successfully!")
    return render_template('instanceSegmentation.html', form=form)


# function to process uploaded file and make inference
def preprocesDataAndMakeInference(filename):


  # configure
    config = get_cfg()
    config.merge_from_file(model_zoo.get_config_file("COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml"))
    config.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.9 # set threshold for this model
    config.MODEL.WEIGHTS = "/content/drive/MyDrive/instance_segmentation/Detectron2/logs_6/model_final.pth"
    config.MODEL.ROI_HEADS.NUM_CLASSES = 1
    inference = DefaultPredictor(config)

    # register dataset
    #for d in ["train_clean", "val_clean"]:
        #register_coco_instances(f"goat_{d}", {},
                               #f"/content/drive/MyDrive/instance_segmentation/Detection2/datasets/{d}/via_region_data_coco.json",
                               #f"/content/drive/MyDrive/instance_segmentation/Detection2/datasets/{d}")


    # set object class
    clean_instance = MetadataCatalog.get("goat_train_clean").set(thing_classes=["goat"])

    # process image
    filename = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    filename = cv2.imread(filename)
    output = inference(filename)
    visualizer = Visualizer(filename[:, :, ::-1], metadata = clean_instance,
                            instance_mode=ColorMode.IMAGE_BW, scale=0.9)
    out = visualizer.draw_instance_predictions(output["instances"].to("cpu"))
    prediction = out.get_image()[:, :, ::-1]
    return prediction


@app.route('/predict', methods=['GET', 'POST'])
def predict():

    if request.method == 'POST':
        # Check if the post request has the file part
        if 'file' not in request.files:
            return "No file part"

        file = request.files['file']


            # If the user does not select a file, the browser submits an empty part without a filename
        if file.filename == '':
            return "No selected file"

        if file and allowed_file(file.filename):
            # Save the uploaded file
            filename = secure_filename(file.filename)
            image_file = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(image_file)

            # Get most recent saved file
            # https://jacobnarayan.com/blogs/how-to-find-the-most-recent-file-in-a-directory-in-python -> borrowed this code
            # Narayan, Jacob (2023) How to Find The Most Recent File in a Directory in Python [Source Code]. https://jacobnarayan.com/blogs/how-to-find-the-most-recent-file-in-a-directory-in-python
            most_recent_file = None
            most_recent_time = 0
            for entry in os.scandir(app.config['UPLOAD_FOLDER']):
                if entry.is_file():
                    if entry.name.endswith(tuple(['.jpg', '.jpeg'])):
                        mod_time = entry.stat().st_mtime_ns
                        if mod_time > most_recent_time:
                            most_recent_file = entry.name
                            most_recent_time = mod_time
            #-------------------------------------------------------------------------------
            # Process the most recent uploaded image for prediction and send it from prediction directory
            prediction = preprocesDataAndMakeInference(most_recent_file) #function returns an array of pixels
            conv_img = Image.fromarray(prediction) #convert pixels into an image
            conv_img.save(os.path.join(app.config['PREDICTION_FOLDER'], 'prediction.jpg')) #save conversion into directory
            return send_from_directory(app.config['PREDICTION_FOLDER'], 'prediction.jpg') #return prediction

print(f"Click this link to access my flask app on google colab -> {public_url}")

if __name__ == '__main__':
#run app on google server
    app.run(port=port)

"""# Package Versions"""

import flask
print(f'flask: {flask.__version__}')

#import pyngrok
#print(pyngrok.__version__) has no attribute version

import flask_bootstrap
print(f'flask_bootstrap: {flask_bootstrap.__version__}')

import flask_wtf
print(f'flask_wtf: {flask_wtf.__version__}')

import wtforms
print(f'wtforms: {wtforms.__version__}')

import werkzeug
print(f'werkzeug: {werkzeug.__version__}')

import torch
print(f'torch: {torch.__version__}')

import torchvision
print(f'torchvision: {torchvision.__version__}')

import cv2
print(f'cv2: {cv2.__version__}')

#import os
#print(os.__version__) has not attribute version

#import io
#print(io.__version__)

#import base64
#print(base64.__version__) has no attribute version

import detectron2
print(f'detectron2: {detectron2.__version__}')

import skimage
print(f'skimage: {skimage.__version__}')

import matplotlib
print(f'matplotlib: {matplotlib.__version__}')

import PIL
print(f'PIL: {PIL.__version__}')